# ProtoBuilder internals

## Internal classes

WARNING: Everything below is internal documentation for people who want to
contribute to ProtoBuilder's code generation framework.

### `enum Where` {#Where}

C++ code generation needs to write two types of files. The header file that
mostly declarations and whose filenames end with `.h` and the source files that
hold implmentations and whose filenames end with `.cc`. The `Where` enum
distinguishes the two target types:

For reference, please refer to https://google.github.io/cpp-proto-builder/proto_builder/builder_writer.h class:Where

### `BuilderWriter` {#BuilderWriter}

`BuilderWriter` is an interface that handles all code output. It is designed to
be decorated/wrapped, that is one `BuilderWriter` class can wrap around another.
The interface als allows access to a [`CodeInfoCollector`](#CodeInfoCollector)
which must exist exactly once throughout code generation.

The core semantic of the builder is that each writer instance handles all output
files for the current file set. The separate files are addressed using the `enum
Where` (`HEADER` = .h, `SOURCE` = .cc). And it is assumed that each file set
handles exactly one message type.

Further, each generated line of code needs to be send to the writer as a full
line without new-line characters.

If a generator wants to write multiple lines it can wrap its writer with the
[`SplitLinesWriter`](#SplitLinesWriter) writer.

> IMPORTANT: A Writer wrapper class must always take a `BuilderWriter*` as the
> first argument. This may be followed with an arbitrary list of arguments. To
> simplify wrapping all wrappers should inherit from `WrappingBuilderWriter`:
>
> *   `WrappingBuilderWriter` {#WrappingBuilderWriter}
>
>     For reference, please refer to https://google.github.io/cpp-proto-builder/proto_builder/builder_writer.h class:WrappingBuilderWriter

The following decorator writers exist:

*   `NoDoubleEmptyLineWriter` {#NoDoubleEmptyLineWriter}

    Writer decorator that prevents the first line and any two consecutive lines
    from being empty. This writer allows us to simplify code generation without
    having to worry about double empty lines. So instead of tracking whether the
    last line was empty, a code generator that wants an empty line simply writes
    an empty line and we do not have to transfer or track knowledge about emty
    lines.

*   `SplitLinesWriter` {#SplitLinesWriter}

    A writer usually assumes each Write() call is for a single line. This writer
    allows to simplify code generation by no longer requiring that the generator
    adheres to this API. Instead the generator simply wraps its writer with this
    decorator and that way adhere to the contract no matter how it deals with
    new line characters.

*   `IndentWriter` {#IndentWriter}

    This writer inserts a specified indent to the beginning of each empty line.
    It is used to indent the header code generated by `FieldBuilder` when used
    for `MessageBuilder`.

*   `OwnWrappedWriter` {#OwnWrappedWriter}

    Since wrapping writers do not own their wrapped writers they cannot partake
    in the memory management of the wrapped writers. The `OwnWrappedWriter`
    changes a wrapping writer to own its wrapped writer and dispose of it when
    itself gets destructed.

    This allows to build a chain of wrapped writers where the caller retains
    ownership of the outermost writer but not of the innermost one as follows:

    ```c++
    std::unique_ptr<BuilderWriter> writer = std::move(
        OwnWrappedWriter<NoDoubleEmptyLineWriter>::New(
          std::make_unique<IndentWriter>(writer, "  ")));
    ```

    If the innermost writer should also be owned, then the example becomes:

    ```c++
    std::unique_ptr<BuilderWriter> writer = std::move(
        OwnWrappedWriter<NoDoubleEmptyLineWriter>::New(
          OwnWrappedWriter<IndentWriter>::New(
            absl::WrapUnique(writer), "  ")));
    ```

As stated before, these writers are designed to be chained/wrapped to combine
their functionality. For instance a `Builder` might want to buffer writes and
not care about new line characters or the number of consecutive empty lines. In
the following example the original `writer` will never receive a new-line
character or more than one empty line in a row, while all header lines will be
indented:

```c++
Class Builder {
 public:
  Builder(BuilderWriter* writer)
      : owned_writer_(OwnedWrappedWriter<SplitLinesWriter>::New(
          OwnedWrappedWriter<NoDoubleEmptyLineWriter>::New(
            std::make_unique<IndentWriter>(writer, "  ")))) {}

  void Write(Where to, const std::string& text) {
    owned_writer_->Write(to, text);
  }

 private:
  std::unique_ptr<BuilderWriter> owned_writer_;
}
```

NOTE: Builder does not own the original `writer`.

### `BufferWriter` {#BufferWriter}

This class allows code generators or receivers to buffer generated code before
writing it all at once. This object also holds an actual `CodeInfoCollector`
instance. It is not a `WrappingBuilderWriter` but rather a `BuilderWriter`.

### `CodeInfoCollector` {#CodeInfoCollector}

The `CodeInfoCollector` is available from all `BuilderWriter` instances and
responsible include tracking. That is any generator that writes code that
requires a type to be loaded from an include statement can simply call one of:

*   `writer->CodeInfo()->AddInclude(Where where, absl::string_view include)`
*   `writer->CodeInfo()->AddInclude(Where where, const proto2::Descriptor msg)`
*   `writer->CodeInfo()->AddInclude(Where where, const proto2::EnumDescriptor
    msg)`

The first allows to add includes directly (e.g. `<string>` or `"my/type.h"`).
The quotes are optional, unless the include requires a comment (e.g. `// IWYU
pragma: export`).

The second and third method allow to generate the include line for message and
enum types automatically. They will always add the [IWYU](http://include-what-you-use.org)
pragma.

### `FieldBuilder` {#FieldBuilder}

Class generator for a single field.

### `MessageBuilder` {#MessageBuilder}

Class that handles code generation for a single message type.

### `TemplateBuilder` {#TemplateBuilder}

Class that generates code for a single message type and uses it in an expanded
template. This allows to create complete header and source files.
